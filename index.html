<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meme Generator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container-fluid py-2">
        <!-- Mobile Header -->
        <header class="mobile-header d-block d-lg-none">
            <div class="d-flex justify-content-between align-items-center mb-2">
                <h1 class="h4 fw-bold text-primary mb-0">üé® Meme Generator</h1>
                <div class="dark-mode-toggle">
                    <input type="checkbox" id="darkModeToggle" class="d-none">
                    <label for="darkModeToggle" class="dark-mode-switch">
                        <span class="sun">‚òÄÔ∏è</span>
                        <span class="moon">üåô</span>
                        <div class="toggle-circle"></div>
                    </label>
                </div>
            </div>
        </header>

        <!-- Desktop Header -->
        <header class="desktop-header d-none d-lg-block text-center mb-3">
            <div class="d-flex justify-content-between align-items-center">
                <h1 class="display-5 fw-bold text-primary">üé® Meme Generator</h1>
                <div class="dark-mode-toggle">
                    <input type="checkbox" id="darkModeToggleDesktop" class="d-none">
                    <label for="darkModeToggleDesktop" class="dark-mode-switch">
                        <span class="sun">‚òÄÔ∏è</span>
                        <span class="moon">üåô</span>
                        <div class="toggle-circle"></div>
                    </label>
                </div>
            </div>
            <p class="text-muted mt-2">Create professional memes with drag & drop text</p>
        </header>

        <div class="row g-2">
            <!-- Mobile Template Picker (Bottom Sheet) -->
            <div class="col-12 d-block d-lg-none">
                <div class="mobile-templates">
                    <button class="btn btn-primary w-100 mb-2" onclick="toggleTemplateDrawer()">
                        üìÅ Choose Template
                    </button>
                    <div class="template-drawer" id="templateDrawer">
                        <div class="template-drawer-header">
                            <h6 class="mb-0">Select Template</h6>
                            <button class="btn-close" onclick="toggleTemplateDrawer()"></button>
                        </div>
                        <div class="template-drawer-content">
                            <div class="template-search mb-2">
                                <input type="text" class="form-control form-control-sm" placeholder="üîç Search templates..." id="mobileTemplateSearch">
                            </div>
                            <div class="mobile-template-grid" id="mobileTemplateGrid">
                                <!-- Mobile templates will be loaded here -->
                            </div>
                            <div class="upload-section mt-2">
                                <input type="file" class="form-control form-control-sm mb-2" id="mobileUploadTemplate" accept="image/*">
                                <button class="btn btn-outline-primary btn-sm w-100" onclick="addUserTemplateMobile()">Upload Image</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Left Panel - Controls (Desktop) -->
            <div class="col-lg-3 d-none d-lg-block">
                <div class="card shadow-sm sidebar-card">
                    <div class="card-body">
                        <h5 class="card-title">üìÅ Templates</h5>
                        
                        <div class="template-search mb-3">
                            <input type="text" class="form-control form-control-sm" placeholder="üîç Search templates..." id="templateSearch">
                        </div>
                        
                        <div class="template-gallery">
                            <div class="desktop-template-grid" id="desktopTemplateGrid">
                                <!-- Desktop templates will be loaded here -->
                            </div>
                        </div>

                        <div class="upload-section mt-3">
                            <input type="file" class="form-control form-control-sm mb-2" id="uploadTemplate" accept="image/*">
                            <button class="btn btn-outline-primary btn-sm w-100" onclick="addUserTemplate()">Upload Your Image</button>
                        </div>
                    </div>
                </div>

                <div class="card shadow-sm sidebar-card mt-3">
                    <div class="card-body">
                        <h5 class="card-title">‚úèÔ∏è Text Editor</h5>
                        
                        <div class="text-controls">
                            <div class="d-flex gap-2 mb-3">
                                <button class="btn btn-primary btn-sm flex-fill" onclick="addTextArea()">
                                    <i class="fas fa-plus"></i> Add Text
                                </button>
                                <button class="btn btn-outline-danger btn-sm" onclick="clearAllText()">
                                    <i class="fas fa-trash"></i> Clear
                                </button>
                            </div>

                            <div class="text-areas-container" id="textAreasContainer">
                                <!-- Text areas will be added here -->
                            </div>

                            <div class="text-properties mt-3">
                                <div class="property-group">
                                    <label class="form-label">Font Size</label>
                                    <input type="range" class="form-range" id="textSize" min="20" max="80" value="36">
                                    <div class="text-center small" id="textSizeValue">36px</div>
                                </div>

                                <div class="property-group">
                                    <label class="form-label">Stroke Width</label>
                                    <input type="range" class="form-range" id="strokeWidth" min="0" max="6" value="3">
                                    <div class="text-center small" id="strokeWidthValue">3px</div>
                                </div>

                                <div class="row g-2 mt-2">
                                    <div class="col-6">
                                        <label class="form-label">Text Color</label>
                                        <input type="color" class="form-control form-control-color" id="textColor" value="#ffffff">
                                    </div>
                                    <div class="col-6">
                                        <label class="form-label">Stroke Color</label>
                                        <input type="color" class="form-control form-control-color" id="strokeColor" value="#000000">
                                    </div>
                                </div>

                                <div class="row g-2 mt-2">
                                    <div class="col-12">
                                        <label class="form-label">Font Family</label>
                                        <select class="form-select" id="fontFamily">
                                            <option value="Impact">Impact (Classic)</option>
                                            <option value="Arial Black">Arial Black</option>
                                            <option value="Comic Sans MS">Comic Sans</option>
                                            <option value="Verdana">Verdana</option>
                                            <option value="Georgia">Georgia</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="action-buttons mt-3">
                            <button class="btn btn-success w-100 mb-2" onclick="updateCanvas()">
                                <i class="fas fa-sync"></i> Update Meme
                            </button>
                            <button class="btn btn-primary w-100" onclick="downloadMeme()">
                                <i class="fas fa-download"></i> Download Meme
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main Canvas Area -->
            <div class="col-lg-9 col-12">
                <div class="card shadow-sm main-canvas-card">
                    <div class="card-body p-2">
                        <div class="canvas-container" id="canvasContainer">
                            <canvas id="memeCanvas"></canvas>
                            <div class="canvas-overlay" id="canvasOverlay">
                                <!-- Text areas will be positioned here -->
                            </div>
                            
                            <!-- Mobile Controls -->
                            <div class="mobile-controls d-flex d-lg-none">
                                <div class="mobile-control-group">
                                    <button class="btn btn-sm btn-outline-primary" onclick="addTextArea()">
                                        <i class="fas fa-plus"></i> Text
                                    </button>
                                    <button class="btn btn-sm btn-outline-secondary" onclick="zoomOut()">
                                        <i class="fas fa-search-minus"></i>
                                    </button>
                                    <span class="zoom-value" id="mobileZoomValue">100%</span>
                                    <button class="btn btn-sm btn-outline-secondary" onclick="zoomIn()">
                                        <i class="fas fa-search-plus"></i>
                                    </button>
                                    <button class="btn btn-sm btn-outline-success" onclick="downloadMeme()">
                                        <i class="fas fa-download"></i>
                                    </button>
                                </div>
                            </div>

                            <!-- Desktop Controls -->
                            <div class="desktop-controls d-none d-lg-flex">
                                <div class="control-group">
                                    <button class="btn btn-sm btn-outline-secondary" onclick="zoomOut()">‚àí</button>
                                    <span class="zoom-value" id="desktopZoomValue">100%</span>
                                    <button class="btn btn-sm btn-outline-secondary" onclick="zoomIn()">+</button>
                                    <button class="btn btn-sm btn-outline-secondary" onclick="resetZoom()">Reset</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Mobile Instructions -->
                        <div class="mobile-instructions d-block d-lg-none text-center mt-2">
                            <small class="text-muted">
                                üëÜ Drag text to move ‚Ä¢ üì± Pinch to zoom
                            </small>
                        </div>

                        <!-- Desktop Instructions -->
                        <div class="desktop-instructions d-none d-lg-block text-center mt-2">
                            <small class="text-muted">
                                üí° Drag text areas to reposition ‚Ä¢ Scroll to zoom ‚Ä¢ Right-click to pan
                            </small>
                        </div>
                    </div>
                </div>

                <!-- Mobile Text Properties Panel -->
                <div class="mobile-text-panel d-block d-lg-none mt-2">
                    <div class="card shadow-sm">
                        <div class="card-body">
                            <div class="text-properties-mobile">
                                <div class="row g-2">
                                    <div class="col-4">
                                        <label class="form-label small">Size</label>
                                        <input type="range" class="form-range" id="mobileTextSize" min="20" max="80" value="36">
                                        <div class="text-center x-small" id="mobileTextSizeValue">36px</div>
                                    </div>
                                    <div class="col-4">
                                        <label class="form-label small">Stroke</label>
                                        <input type="range" class="form-range" id="mobileStrokeWidth" min="0" max="6" value="3">
                                        <div class="text-center x-small" id="mobileStrokeWidthValue">3px</div>
                                    </div>
                                    <div class="col-4">
                                        <label class="form-label small">Font</label>
                                        <select class="form-select form-select-sm" id="mobileFontFamily">
                                            <option value="Impact">Impact</option>
                                            <option value="Arial Black">Arial</option>
                                            <option value="Comic Sans MS">Comic</option>
                                        </select>
                                    </div>
                                    <div class="col-6">
                                        <label class="form-label small">Text Color</label>
                                        <input type="color" class="form-control form-control-color form-control-sm" id="mobileTextColor" value="#ffffff">
                                    </div>
                                    <div class="col-6">
                                        <label class="form-label small">Stroke Color</label>
                                        <input type="color" class="form-control form-control-color form-control-sm" id="mobileStrokeColor" value="#000000">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile Bottom Navigation -->
    <nav class="mobile-nav d-flex d-lg-none">
        <button class="nav-btn active" onclick="showSection('templates')">
            <i class="fas fa-images"></i>
            <span>Templates</span>
        </button>
        <button class="nav-btn" onclick="showSection('text')">
            <i class="fas fa-font"></i>
            <span>Text</span>
        </button>
        <button class="nav-btn" onclick="showSection('style')">
            <i class="fas fa-palette"></i>
            <span>Style</span>
        </button>
        <button class="nav-btn" onclick="downloadMeme()">
            <i class="fas fa-download"></i>
            <span>Download</span>
        </button>
    </nav>

    <!-- Mobile Sections -->
    <div class="mobile-sections">
        <div class="mobile-section" id="templatesSection">
            <!-- Template content will be loaded here -->
        </div>
        <div class="mobile-section" id="textSection" style="display: none;">
            <!-- Text content will be loaded here -->
        </div>
        <div class="mobile-section" id="styleSection" style="display: none;">
            <!-- Style content will be loaded here -->
        </div>
    </div>

    <script>
        // Meme Generator Application
        class MemeGenerator {
            constructor() {
                this.canvas = document.getElementById('memeCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvasOverlay = document.getElementById('canvasOverlay');
                this.textAreasContainer = document.getElementById('textAreasContainer');
                
                this.currentImage = null;
                this.textAreas = [];
                this.canvasScale = 1.0;
                this.canvasOffsetX = 0;
                this.canvasOffsetY = 0;
                this.isDragging = false;
                this.isPanning = false;
                this.currentDragElement = null;
                this.dragOffsetX = 0;
                this.dragOffsetY = 0;
                this.startPanX = 0;
                this.startPanY = 0;
                this.templateDrawerOpen = false;
                
                // High-quality meme templates with better images
                this.memeTemplates = [
                    { 
                        name: "Drake", 
                        url: "https://i.imgflip.com/30b1gx.jpg",
                        category: "popular"
                    },
                    { 
                        name: "Doge", 
                        url: "https://i.imgflip.com/4t0m5.jpg",
                        category: "animals"
                    },
                    { 
                        name: "Two Buttons", 
                        url: "https://i.imgflip.com/1g8my4.jpg",
                        category: "popular"
                    },
                    { 
                        name: "Distracted Boyfriend", 
                        url: "https://i.imgflip.com/1ur9b0.jpg",
                        category: "popular"
                    },
                    { 
                        name: "Change My Mind", 
                        url: "https://i.imgflip.com/24y43o.jpg",
                        category: "debate"
                    },
                    { 
                        name: "Woman Yelling at Cat", 
                        url: "https://i.imgflip.com/345v97.jpg",
                        category: "animals"
                    },
                    { 
                        name: "Left Exit 12", 
                        url: "https://i.imgflip.com/22bdq6.jpg",
                        category: "driving"
                    },
                    { 
                        name: "Running Away Balloon", 
                        url: "https://i.imgflip.com/261o3j.jpg",
                        category: "escape"
                    },
                    { 
                        name: "Winnie the Pooh", 
                        url: "https://i.imgflip.com/2ybua0.jpg",
                        category: "popular"
                    },
                    { 
                        name: "Mocking Spongebob", 
                        url: "https://i.imgflip.com/1otk96.jpg",
                        category: "mock"
                    }
                ];
                
                this.userTemplates = JSON.parse(localStorage.getItem('userTemplates')) || [];
                
                this.init();
            }

            init() {
                this.setupDarkMode();
                this.setupEventListeners();
                this.initializeTemplateGalleries();
                this.loadImage(this.memeTemplates[0].url);
                this.addDefaultTextAreas();
                this.updateZoomDisplay();
                this.setupMobileNavigation();
            }

            setupDarkMode() {
                const setupToggle = (toggleId) => {
                    const toggle = document.getElementById(toggleId);
                    if (!toggle) return;
                    
                    const savedMode = localStorage.getItem('darkMode');
                    if (savedMode === 'enabled') {
                        toggle.checked = true;
                        document.body.classList.add('dark-mode');
                    }
                    
                    toggle.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            document.body.classList.add('dark-mode');
                            localStorage.setItem('darkMode', 'enabled');
                        } else {
                            document.body.classList.remove('dark-mode');
                            localStorage.setItem('darkMode', 'disabled');
                        }
                    });
                };

                setupToggle('darkModeToggle');
                setupToggle('darkModeToggleDesktop');
            }

            setupEventListeners() {
                // Text controls - Desktop
                document.getElementById('textSize')?.addEventListener('input', (e) => {
                    document.getElementById('textSizeValue').textContent = e.target.value + 'px';
                    this.updateAllTextAreas();
                });

                document.getElementById('strokeWidth')?.addEventListener('input', (e) => {
                    document.getElementById('strokeWidthValue').textContent = e.target.value + 'px';
                    this.updateAllTextAreas();
                });

                document.getElementById('textColor')?.addEventListener('input', () => this.updateAllTextAreas());
                document.getElementById('strokeColor')?.addEventListener('input', () => this.updateAllTextAreas());
                document.getElementById('fontFamily')?.addEventListener('change', () => this.updateAllTextAreas());

                // Text controls - Mobile
                document.getElementById('mobileTextSize')?.addEventListener('input', (e) => {
                    document.getElementById('mobileTextSizeValue').textContent = e.target.value + 'px';
                    this.updateAllTextAreas();
                });

                document.getElementById('mobileStrokeWidth')?.addEventListener('input', (e) => {
                    document.getElementById('mobileStrokeWidthValue').textContent = e.target.value + 'px';
                    this.updateAllTextAreas();
                });

                document.getElementById('mobileTextColor')?.addEventListener('input', () => this.updateAllTextAreas());
                document.getElementById('mobileStrokeColor')?.addEventListener('input', () => this.updateAllTextAreas());
                document.getElementById('mobileFontFamily')?.addEventListener('change', () => this.updateAllTextAreas());

                // Template search
                document.getElementById('templateSearch')?.addEventListener('input', (e) => {
                    this.filterTemplates(e.target.value.toLowerCase(), 'desktop');
                });

                document.getElementById('mobileTemplateSearch')?.addEventListener('input', (e) => {
                    this.filterTemplates(e.target.value.toLowerCase(), 'mobile');
                });

                // Canvas interactions
                this.canvas.addEventListener('wheel', (e) => this.handleZoom(e));
                this.canvas.addEventListener('mousedown', (e) => this.startPan(e));
                this.canvas.addEventListener('touchstart', (e) => this.startPanTouch(e), { passive: false });

                // Touch events for mobile
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                this.canvas.addEventListener('touchend', () => this.handleTouchEnd());

                // Window resize
                window.addEventListener('resize', () => {
                    if (this.currentImage) {
                        this.updateCanvasSize();
                        this.updateAllTextAreas();
                    }
                });

                // Prevent pull-to-refresh on mobile
                document.addEventListener('touchmove', (e) => {
                    if (this.isDragging || this.isPanning) {
                        e.preventDefault();
                    }
                }, { passive: false });
            }

            setupMobileNavigation() {
                // Setup mobile bottom nav
                const navButtons = document.querySelectorAll('.mobile-nav .nav-btn');
                navButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        navButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    });
                });
            }

            initializeTemplateGalleries() {
                this.loadTemplatesToGrid('desktop');
                this.loadTemplatesToGrid('mobile');
            }

            loadTemplatesToGrid(type) {
                const gridId = type === 'mobile' ? 'mobileTemplateGrid' : 'desktopTemplateGrid';
                const grid = document.getElementById(gridId);
                if (!grid) return;

                const allTemplates = [...this.memeTemplates, ...this.userTemplates];
                
                grid.innerHTML = '';
                
                allTemplates.forEach((template, index) => {
                    const templateItem = document.createElement('div');
                    templateItem.className = `template-item ${type}-template-item ${index === 0 ? 'active' : ''}`;
                    templateItem.innerHTML = `
                        <div class="template-image-container">
                            <img src="${template.url}" alt="${template.name}" class="template-img" loading="lazy">
                            <div class="template-overlay">
                                <span class="template-name">${template.name}</span>
                            </div>
                        </div>
                    `;
                    
                    templateItem.addEventListener('click', () => {
                        // Remove active class from all items
                        document.querySelectorAll(`.${type}-template-item`).forEach(item => {
                            item.classList.remove('active');
                        });
                        templateItem.classList.add('active');
                        this.loadImage(template.url);
                        
                        // Close mobile drawer if open
                        if (type === 'mobile') {
                            this.toggleTemplateDrawer(false);
                        }
                    });
                    
                    grid.appendChild(templateItem);
                });
            }

            filterTemplates(searchTerm, type) {
                const allTemplates = [...this.memeTemplates, ...this.userTemplates];
                const filteredTemplates = allTemplates.filter(template => 
                    template.name.toLowerCase().includes(searchTerm)
                );
                
                const gridId = type === 'mobile' ? 'mobileTemplateGrid' : 'desktopTemplateGrid';
                const grid = document.getElementById(gridId);
                if (!grid) return;
                
                grid.innerHTML = '';
                
                if (filteredTemplates.length === 0) {
                    grid.innerHTML = '<div class="no-templates">No templates found for "' + searchTerm + '"</div>';
                    return;
                }
                
                filteredTemplates.forEach((template, index) => {
                    const templateItem = document.createElement('div');
                    templateItem.className = `template-item ${type}-template-item ${index === 0 ? 'active' : ''}`;
                    templateItem.innerHTML = `
                        <div class="template-image-container">
                            <img src="${template.url}" alt="${template.name}" class="template-img">
                            <div class="template-overlay">
                                <span class="template-name">${template.name}</span>
                            </div>
                        </div>
                    `;
                    
                    templateItem.addEventListener('click', () => {
                        document.querySelectorAll(`.${type}-template-item`).forEach(item => {
                            item.classList.remove('active');
                        });
                        templateItem.classList.add('active');
                        this.loadImage(template.url);
                        
                        if (type === 'mobile') {
                            this.toggleTemplateDrawer(false);
                        }
                    });
                    
                    grid.appendChild(templateItem);
                });
            }

            loadImage(url) {
                this.currentImage = new Image();
                this.currentImage.crossOrigin = "anonymous";
                this.currentImage.src = url;
                
                this.currentImage.onload = () => {
                    this.updateCanvasSize();
                    this.textAreas = [];
                    this.canvasOverlay.innerHTML = '';
                    this.textAreasContainer.innerHTML = '';
                    this.addDefaultTextAreas();
                    this.updateCanvas();
                };
                
                this.currentImage.onerror = () => {
                    console.error('Failed to load image:', url);
                    alert('Failed to load image. Please try another template.');
                };
            }

            updateCanvasSize() {
                const container = document.getElementById('canvasContainer');
                const maxWidth = container.clientWidth - 40;
                const maxHeight = window.innerHeight * 0.6;
                
                let scale = maxWidth / this.currentImage.width;
                if (this.currentImage.height * scale > maxHeight) {
                    scale = maxHeight / this.currentImage.height;
                }
                
                this.canvas.width = this.currentImage.width * scale;
                this.canvas.height = this.currentImage.height * scale;
                
                // Update overlay size
                this.canvasOverlay.style.width = this.canvas.width + 'px';
                this.canvasOverlay.style.height = this.canvas.height + 'px';
            }

            addDefaultTextAreas() {
                this.addTextArea("TOP TEXT", 50, 20);
                this.addTextArea("BOTTOM TEXT", 50, 80);
            }

            addTextArea(text = "YOUR TEXT", x = 50, y = 50) {
                const id = 'text_' + Date.now();
                const textArea = {
                    id,
                    text,
                    x,
                    y
                };
                
                this.textAreas.push(textArea);
                this.createTextAreaElement(textArea);
                this.createTextAreaControl(textArea);
            }

            createTextAreaElement(textArea) {
                const textElement = document.createElement('div');
                textElement.className = 'text-area';
                textElement.id = `text-${textArea.id}`;
                textElement.innerHTML = `
                    <div class="text-content">${textArea.text}</div>
                    <div class="text-handles">
                        <div class="handle drag">‚§Æ</div>
                        <div class="handle delete" onclick="memeGenerator.deleteTextArea('${textArea.id}')">√ó</div>
                    </div>
                `;
                
                this.updateTextAreaPosition(textElement, textArea);
                this.updateTextAreaStyle(textElement);
                this.setupTextAreaDrag(textElement, textArea);
                
                this.canvasOverlay.appendChild(textElement);
            }

            createTextAreaControl(textArea) {
                if (!this.textAreasContainer) return;
                
                const control = document.createElement('div');
                control.className = 'text-area-control';
                control.innerHTML = `
                    <div class="d-flex align-items-center gap-2 p-2 border rounded">
                        <input type="text" 
                               class="form-control form-control-sm" 
                               value="${textArea.text}" 
                               placeholder="Enter text..."
                               oninput="memeGenerator.updateTextAreaText('${textArea.id}', this.value)">
                        <button class="btn btn-sm btn-outline-danger" onclick="memeGenerator.deleteTextArea('${textArea.id}')">√ó</button>
                    </div>
                `;
                
                this.textAreasContainer.appendChild(control);
            }

            setupTextAreaDrag(textElement, textArea) {
                const dragHandle = textElement.querySelector('.handle.drag');
                const textContent = textElement.querySelector('.text-content');
                
                // Make entire text area draggable on mobile
                if (window.innerWidth < 992) {
                    textContent.style.cursor = 'move';
                    textContent.addEventListener('touchstart', (e) => this.startTextDrag(e, textElement, textArea));
                }
                
                dragHandle.addEventListener('mousedown', (e) => this.startTextDrag(e, textElement, textArea));
                dragHandle.addEventListener('touchstart', (e) => this.startTextDrag(e, textElement, textArea), { passive: false });
            }

            startTextDrag(e, textElement, textArea) {
                e.preventDefault();
                e.stopPropagation();
                
                this.isDragging = true;
                this.currentDragElement = textArea;
                
                const rect = textElement.getBoundingClientRect();
                const canvasRect = this.canvas.getBoundingClientRect();
                
                if (e.type === 'touchstart') {
                    const touch = e.touches[0];
                    this.dragOffsetX = touch.clientX - rect.left;
                    this.dragOffsetY = touch.clientY - rect.top;
                    
                    document.addEventListener('touchmove', this.dragText.bind(this));
                    document.addEventListener('touchend', this.stopTextDrag.bind(this));
                } else {
                    this.dragOffsetX = e.clientX - rect.left;
                    this.dragOffsetY = e.clientY - rect.top;
                    
                    document.addEventListener('mousemove', this.dragText.bind(this));
                    document.addEventListener('mouseup', this.stopTextDrag.bind(this));
                }
            }

            dragText(e) {
                if (!this.isDragging || !this.currentDragElement) return;
                
                let clientX, clientY;
                
                if (e.type === 'touchmove') {
                    e.preventDefault();
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                const canvasRect = this.canvas.getBoundingClientRect();
                const textElement = document.getElementById(`text-${this.currentDragElement.id}`);
                
                if (!textElement) return;
                
                const x = ((clientX - this.dragOffsetX - canvasRect.left + textElement.offsetWidth / 2) / canvasRect.width) * 100;
                const y = ((clientY - this.dragOffsetY - canvasRect.top + textElement.offsetHeight / 2) / canvasRect.height) * 100;
                
                this.currentDragElement.x = Math.max(5, Math.min(95, x));
                this.currentDragElement.y = Math.max(5, Math.min(95, y));
                
                this.updateTextAreaPosition(textElement, this.currentDragElement);
            }

            stopTextDrag() {
                this.isDragging = false;
                this.currentDragElement = null;
                document.removeEventListener('mousemove', this.dragText);
                document.removeEventListener('touchmove', this.dragText);
                document.removeEventListener('mouseup', this.stopTextDrag);
                document.removeEventListener('touchend', this.stopTextDrag);
                this.updateCanvas();
            }

            updateTextAreaPosition(textElement, textArea) {
                const canvasRect = this.canvas.getBoundingClientRect();
                const x = (textArea.x / 100) * canvasRect.width;
                const y = (textArea.y / 100) * canvasRect.height;
                
                textElement.style.left = (x - textElement.offsetWidth / 2) + 'px';
                textElement.style.top = (y - textElement.offsetHeight / 2) + 'px';
            }

            updateTextAreaStyle(textElement) {
                const textSize = this.getTextSize();
                const strokeWidth = this.getStrokeWidth();
                const textColor = this.getTextColor();
                const strokeColor = this.getStrokeColor();
                const fontFamily = this.getFontFamily();
                
                textElement.style.fontSize = textSize + 'px';
                textElement.style.color = textColor;
                textElement.style.fontFamily = fontFamily;
                textElement.style.textShadow = `
                    ${strokeWidth}px ${strokeWidth}px 0 ${strokeColor},
                    -${strokeWidth}px -${strokeWidth}px 0 ${strokeColor},
                    ${strokeWidth}px -${strokeWidth}px 0 ${strokeColor},
                    -${strokeWidth}px ${strokeWidth}px 0 ${strokeColor}
                `;
            }

            getTextSize() {
                return document.getElementById('mobileTextSize')?.value || 
                       document.getElementById('textSize')?.value || 36;
            }

            getStrokeWidth() {
                return document.getElementById('mobileStrokeWidth')?.value || 
                       document.getElementById('strokeWidth')?.value || 3;
            }

            getTextColor() {
                return document.getElementById('mobileTextColor')?.value || 
                       document.getElementById('textColor')?.value || '#ffffff';
            }

            getStrokeColor() {
                return document.getElementById('mobileStrokeColor')?.value || 
                       document.getElementById('strokeColor')?.value || '#000000';
            }

            getFontFamily() {
                return document.getElementById('mobileFontFamily')?.value || 
                       document.getElementById('fontFamily')?.value || 'Impact';
            }

            updateTextAreaText(id, newText) {
                const textArea = this.textAreas.find(area => area.id === id);
                if (textArea) {
                    textArea.text = newText;
                    const textElement = document.getElementById(`text-${id}`);
                    if (textElement) {
                        textElement.querySelector('.text-content').textContent = newText;
                    }
                    this.updateCanvas();
                }
            }

            updateAllTextAreas() {
                this.textAreas.forEach(textArea => {
                    const textElement = document.getElementById(`text-${textArea.id}`);
                    if (textElement) {
                        this.updateTextAreaStyle(textElement);
                    }
                });
                this.updateCanvas();
            }

            deleteTextArea(id) {
                this.textAreas = this.textAreas.filter(area => area.id !== id);
                
                // Remove from DOM
                const textElement = document.getElementById(`text-${id}`);
                if (textElement) textElement.remove();
                
                // Remove control
                if (this.textAreasContainer) {
                    const controls = this.textAreasContainer.querySelectorAll('.text-area-control');
                    controls.forEach(control => {
                        if (control.querySelector(`[oninput*="${id}"]`)) {
                            control.remove();
                        }
                    });
                }
                
                this.updateCanvas();
            }

            clearAllText() {
                if (confirm('Are you sure you want to remove all text areas?')) {
                    this.textAreas = [];
                    this.canvasOverlay.innerHTML = '';
                    if (this.textAreasContainer) {
                        this.textAreasContainer.innerHTML = '';
                    }
                    this.updateCanvas();
                }
            }

            handleZoom(e) {
                e.preventDefault();
                const zoomIntensity = 0.1;
                const wheel = e.deltaY < 0 ? 1 : -1;
                const zoom = Math.exp(wheel * zoomIntensity);
                
                this.canvasScale = Math.max(0.3, Math.min(3, this.canvasScale * zoom));
                this.updateZoomDisplay();
                this.updateCanvas();
            }

            handleTouchMove(e) {
                if (e.touches.length === 2) {
                    // Handle pinch to zoom
                    e.preventDefault();
                    this.handlePinchZoom(e);
                } else if (this.isPanning && e.touches.length === 1) {
                    // Handle panning
                    e.preventDefault();
                    this.panTouch(e);
                }
            }

            handlePinchZoom(e) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                const currentDistance = Math.hypot(
                    touch1.clientX - touch2.clientX,
                    touch1.clientY - touch2.clientY
                );
                
                if (this.lastPinchDistance) {
                    const zoom = currentDistance / this.lastPinchDistance;
                    this.canvasScale = Math.max(0.3, Math.min(3, this.canvasScale * zoom));
                    this.updateZoomDisplay();
                    this.updateCanvas();
                }
                
                this.lastPinchDistance = currentDistance;
            }

            handleTouchEnd() {
                this.lastPinchDistance = null;
                this.stopPan();
            }

            startPan(e) {
                if (e.button !== 0 || this.isDragging) return;
                this.isPanning = true;
                this.startPanX = e.clientX - this.canvasOffsetX;
                this.startPanY = e.clientY - this.canvasOffsetY;
                this.canvas.style.cursor = 'grabbing';
                
                document.addEventListener('mousemove', this.pan.bind(this));
                document.addEventListener('mouseup', this.stopPan.bind(this));
            }

            startPanTouch(e) {
                if (e.touches.length === 1 && !this.isDragging) {
                    this.isPanning = true;
                    this.startPanX = e.touches[0].clientX - this.canvasOffsetX;
                    this.startPanY = e.touches[0].clientY - this.canvasOffsetY;
                    
                    document.addEventListener('touchmove', this.panTouch.bind(this), { passive: false });
                    document.addEventListener('touchend', this.stopPan.bind(this));
                }
            }

            pan(e) {
                if (!this.isPanning) return;
                this.canvasOffsetX = e.clientX - this.startPanX;
                this.canvasOffsetY = e.clientY - this.startPanY;
                this.updateCanvas();
            }

            panTouch(e) {
                if (!this.isPanning) return;
                e.preventDefault();
                if (e.touches.length === 1) {
                    this.canvasOffsetX = e.touches[0].clientX - this.startPanX;
                    this.canvasOffsetY = e.touches[0].clientY - this.startPanY;
                    this.updateCanvas();
                }
            }

            stopPan() {
                this.isPanning = false;
                this.canvas.style.cursor = 'default';
                document.removeEventListener('mousemove', this.pan);
                document.removeEventListener('touchmove', this.panTouch);
                document.removeEventListener('mouseup', this.stopPan);
                document.removeEventListener('touchend', this.stopPan);
            }

            zoomIn() {
                this.canvasScale = Math.min(3, this.canvasScale + 0.2);
                this.updateZoomDisplay();
                this.updateCanvas();
            }

            zoomOut() {
                this.canvasScale = Math.max(0.3, this.canvasScale - 0.2);
                this.updateZoomDisplay();
                this.updateCanvas();
            }

            resetZoom() {
                this.canvasScale = 1.0;
                this.canvasOffsetX = 0;
                this.canvasOffsetY = 0;
                this.updateZoomDisplay();
                this.updateCanvas();
            }

            updateZoomDisplay() {
                const zoomValue = Math.round(this.canvasScale * 100) + '%';
                document.getElementById('mobileZoomValue').textContent = zoomValue;
                document.getElementById('desktopZoomValue').textContent = zoomValue;
            }

            updateCanvas() {
                if (!this.currentImage || !this.currentImage.complete) return;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Apply zoom and pan transformations
                this.ctx.save();
                this.ctx.translate(this.canvasOffsetX, this.canvasOffsetY);
                this.ctx.scale(this.canvasScale, this.canvasScale);
                
                // Draw image
                this.ctx.drawImage(this.currentImage, 0, 0, this.canvas.width, this.canvas.height);
                
                // Draw text areas
                const textSize = this.getTextSize();
                const strokeWidth = this.getStrokeWidth();
                const textColor = this.getTextColor();
                const strokeColor = this.getStrokeColor();
                const fontFamily = this.getFontFamily();
                
                this.textAreas.forEach(textArea => {
                    if (!textArea.text) return;
                    
                    this.ctx.font = `bold ${textSize}px ${fontFamily}`;
                    this.ctx.fillStyle = textColor;
                    this.ctx.strokeStyle = strokeColor;
                    this.ctx.lineWidth = strokeWidth;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    const x = (textArea.x / 100) * this.canvas.width;
                    const y = (textArea.y / 100) * this.canvas.height;
                    
                    // Draw stroke
                    if (strokeWidth > 0) {
                        this.ctx.strokeText(textArea.text.toUpperCase(), x, y);
                    }
                    
                    // Draw fill
                    this.ctx.fillText(textArea.text.toUpperCase(), x, y);
                });
                
                this.ctx.restore();
            }

            downloadMeme() {
                if (!this.currentImage || !this.currentImage.complete) {
                    alert('Please wait for the image to load');
                    return;
                }
                
                // Create high-quality canvas
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                // Use original dimensions for best quality
                tempCanvas.width = this.currentImage.width;
                tempCanvas.height = this.currentImage.height;
                
                // Draw image
                tempCtx.drawImage(this.currentImage, 0, 0, tempCanvas.width, tempCanvas.height);
                
                // Scale text properties
                const textSize = parseInt(this.getTextSize());
                const strokeWidth = parseInt(this.getStrokeWidth());
                const textColor = this.getTextColor();
                const strokeColor = this.getStrokeColor();
                const fontFamily = this.getFontFamily();
                
                const scaleFactor = tempCanvas.width / this.canvas.width;
                const scaledTextSize = textSize * scaleFactor;
                const scaledStrokeWidth = strokeWidth * scaleFactor;
                
                // Draw text
                this.textAreas.forEach(textArea => {
                    if (!textArea.text) return;
                    
                    tempCtx.font = `bold ${scaledTextSize}px ${fontFamily}`;
                    tempCtx.fillStyle = textColor;
                    tempCtx.strokeStyle = strokeColor;
                    tempCtx.lineWidth = scaledStrokeWidth;
                    tempCtx.textAlign = 'center';
                    tempCtx.textBaseline = 'middle';
                    
                    const x = (textArea.x / 100) * tempCanvas.width;
                    const y = (textArea.y / 100) * tempCanvas.height;
                    
                    if (scaledStrokeWidth > 0) {
                        tempCtx.strokeText(textArea.text.toUpperCase(), x, y);
                    }
                    tempCtx.fillText(textArea.text.toUpperCase(), x, y);
                });
                
                // Download
                const link = document.createElement('a');
                link.download = 'meme.png';
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
            }

            toggleTemplateDrawer(show) {
                const drawer = document.getElementById('templateDrawer');
                if (show === undefined) {
                    this.templateDrawerOpen = !this.templateDrawerOpen;
                } else {
                    this.templateDrawerOpen = show;
                }
                
                if (drawer) {
                    drawer.classList.toggle('show', this.templateDrawerOpen);
                }
            }

            addUserTemplate() {
                const fileInput = document.getElementById('uploadTemplate');
                this.handleFileUpload(fileInput);
            }

            addUserTemplateMobile() {
                const fileInput = document.getElementById('mobileUploadTemplate');
                this.handleFileUpload(fileInput);
            }

            handleFileUpload(fileInput) {
                const file = fileInput?.files[0];
                
                if (!file) {
                    alert('Please select an image file');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const name = file.name.split('.')[0] || 'Custom Template';
                    const newTemplate = {
                        name: name,
                        url: e.target.result,
                        category: 'custom'
                    };
                    
                    this.userTemplates.push(newTemplate);
                    localStorage.setItem('userTemplates', JSON.stringify(this.userTemplates));
                    
                    // Reload template galleries
                    this.initializeTemplateGalleries();
                    
                    if (fileInput) fileInput.value = '';
                    alert('Template added successfully!');
                };
                reader.readAsDataURL(file);
            }
        }

        // Global functions for HTML onclick attributes
        function addTextArea() {
            memeGenerator.addTextArea();
        }

        function clearAllText() {
            memeGenerator.clearAllText();
        }

        function updateCanvas() {
            memeGenerator.updateCanvas();
        }

        function downloadMeme() {
            memeGenerator.downloadMeme();
        }

        function addUserTemplate() {
            memeGenerator.addUserTemplate();
        }

        function addUserTemplateMobile() {
            memeGenerator.addUserTemplateMobile();
        }

        function zoomIn() {
            memeGenerator.zoomIn();
        }

        function zoomOut() {
            memeGenerator.zoomOut();
        }

        function resetZoom() {
            memeGenerator.resetZoom();
        }

        function toggleTemplateDrawer() {
            memeGenerator.toggleTemplateDrawer();
        }

        function showSection(section) {
            // Hide all sections
            document.querySelectorAll('.mobile-section').forEach(s => {
                s.style.display = 'none';
            });
            
            // Show selected section
            const sectionEl = document.getElementById(section + 'Section');
            if (sectionEl) {
                sectionEl.style.display = 'block';
            }
        }

        // Initialize the application
        let memeGenerator;
        document.addEventListener('DOMContentLoaded', () => {
            memeGenerator = new MemeGenerator();
        });

        // Prevent pull-to-refresh on mobile
        document.addEventListener('touchmove', function(e) {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });

        // Add Font Awesome for icons
        const faLink = document.createElement('link');
        faLink.rel = 'stylesheet';
        faLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css';
        document.head.appendChild(faLink);
    </script>
</body>
</html>
