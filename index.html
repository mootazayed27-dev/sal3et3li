<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Meme Generator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<body>

<div class="container py-1 py-md-3">

    <header class="d-flex flex-column flex-md-row justify-content-between align-items-center mb-2 mb-md-3">
        <h1 class="fw-bold display-5 text-center text-md-start mb-1 mb-md-0 mobile-text-sm">ðŸŽ¨ Meme Generator</h1>
        <div class="d-flex align-items-center">
            <input type="checkbox" id="toggle-dark">
            <label for="toggle-dark" id="darkToggle">
                <div class="circle">
                    <svg class="sun" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 18a6 6 0 100-12 6 6 0 000 12z"/>
                    </svg>

                    <svg class="moon" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M21 12.79A9 9 0 0111.21 3a7 7 0 108.58 8.58 9.05 9.05 0 011.21 1.21z"/>
                    </svg>
                </div>
            </label>
        </div>
    </header>

    <div class="card main-card shadow-lg p-1 p-md-3">
        <h3 class="mb-2 mb-md-3 fw-semibold text-center text-md-start mobile-text-sm">Create Your Meme</h3>

        <div class="row g-2 g-md-3">

            <!-- Left Controls -->
            <div class="col-md-4 pe-md-3 border-end" id="left-panel">

                <!-- Template Gallery -->
                <label class="form-label fw-bold mobile-text-sm">Choose Template</label>
                <div class="template-search">
                    <input type="text" id="templateSearch" class="form-control" placeholder="Search..." style="font-size: 14px;">
                </div>
                
                <div class="template-gallery">
                    <div class="template-section">
                        <h6 class="mobile-text-sm">Popular Templates</h6>
                        <div class="template-grid" id="templateGrid">
                            <!-- Templates will be loaded by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="template-section">
                        <h6 class="mobile-text-sm">My Uploads</h6>
                        <div class="template-grid" id="userTemplatesGrid">
                            <!-- User templates will be loaded here -->
                        </div>
                    </div>
                </div>

                <!-- Upload Section -->
                <div class="upload-section">
                    <h6 class="mobile-text-sm">ðŸ“¤ Upload Template</h6>
                    <input type="file" id="uploadTemplate" class="form-control mb-1" accept="image/*" style="font-size: 14px;">
                    <input type="text" id="templateNameInput" class="form-control mb-1" placeholder="Template name" style="font-size: 14px;">
                    <button onclick="addUserTemplate()" class="btn btn-outline-primary w-100 py-1">Add Template</button>
                </div>

                <!-- Text Mode Toggle -->
                <div class="text-mode-toggle">
                    <button class="btn text-mode-btn active" onclick="setTextMode('single')">Single Line</button>
                    <button class="btn text-mode-btn" onclick="setTextMode('multi')">Multi Line</button>
                </div>

                <!-- Single Line Text Inputs -->
                <div id="singleLineText" class="text-input-section">
                    <label class="form-label fw-bold mobile-text-sm">Top Text</label>
                    <input type="text" id="topText" class="form-control mb-2" placeholder="Top text" oninput="drawMeme()" style="font-size: 14px;">

                    <label class="form-label fw-bold mobile-text-sm">Bottom Text</label>
                    <input type="text" id="bottomText" class="form-control mb-2 mb-md-3" placeholder="Bottom text" oninput="drawMeme()" style="font-size: 14px;">
                </div>

                <!-- Multi Line Text Input -->
                <div id="multiLineText" class="text-input-section" style="display: none;">
                    <label class="form-label fw-bold mobile-text-sm">Meme Text</label>
                    <textarea id="multiText" class="form-control multi-line-input mb-1" placeholder="Enter text line by line&#10;Example:&#10;Hello&#10;World&#10;This is a meme" oninput="drawMeme()" style="font-size: 14px;"></textarea>
                    <div class="multi-line-hint">
                        ðŸ’¡ Each line will be displayed separately. Use Enter to create new lines.
                    </div>
                </div>

                <!-- Text Position Controls -->
                <div class="position-controls">
                    <h6 class="fw-bold mb-2 mobile-text-sm">Text Controls</h6>
                    
                    <div class="drag-instructions mobile-text-xs">
                        ðŸ’¡ Drag circles to move text
                    </div>
                    
                    <div class="slider-group">
                        <label class="mobile-text-sm">Text Size:</label>
                        <div class="slider-container">
                            <input type="range" id="textSize" class="form-range" min="1" max="100" value="20">
                            <span id="textSizeValue" class="slider-value">20px</span>
                        </div>
                    </div>

                    <div class="slider-group">
                        <label class="mobile-text-sm">Stroke Width:</label>
                        <div class="slider-container">
                            <input type="range" id="strokeWidth" class="form-range" min="1" max="10" value="2">
                            <span id="strokeWidthValue" class="slider-value">2px</span>
                        </div>
                    </div>

                    <!-- Color Controls -->
                    <div class="color-controls">
                        <div class="color-group">
                            <label class="mobile-text-sm">Text Color:</label>
                            <div class="color-input-group">
                                <input type="color" id="textColor" value="#ffffff" class="form-control form-control-color" style="width: 35px; height: 35px;">
                                <div id="textColorPreview" class="color-preview" style="background-color: #ffffff;"></div>
                            </div>
                        </div>
                        
                        <div class="color-group">
                            <label class="mobile-text-sm">Stroke Color:</label>
                            <div class="color-input-group">
                                <input type="color" id="strokeColor" value="#000000" class="form-control form-control-color" style="width: 35px; height: 35px;">
                                <div id="strokeColorPreview" class="color-preview" style="background-color: #000000;"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <button onclick="drawMeme()" class="btn btn-primary w-100 mb-1 py-1 fw-semibold">Update</button>
                <button onclick="downloadMeme()" class="btn btn-success w-100 py-1 fw-semibold">Download</button>
            </div>

            <!-- Canvas -->
            <div class="col-md-8 text-center position-relative pinch-container">
                <canvas id="meme-canvas" class="border shadow rounded-3"></canvas>
                <div class="pinch-hint">Pinch to zoom</div>
                <!-- Text handles will be added here by JavaScript -->
            </div>

        </div>
    </div>

</div>

<script>
    const canvas = document.getElementById("meme-canvas");
    const ctx = canvas.getContext("2d");
    let currentImage = new Image();

    // Text position variables
    let topTextX = 50;
    let topTextY = 15;
    let bottomTextX = 50;
    let bottomTextY = 85;
    let textSize = 20;
    let strokeWidth = 2;
    let textColor = "#ffffff";
    let strokeColor = "#000000";
    let textMode = "single"; // "single" or "multi"

    // Drag state variables
    let isDragging = false;
    let currentHandle = null;
    let startX, startY;
    let startTopX, startTopY, startBottomX, startBottomY, startTextSize;

    // Text handles
    let topHandle, bottomHandle, sizeHandle;

    // Touch state for mobile
    let touchStartDistance = 0;
    let initialTextSize = 0;

    // Check if mobile device
    function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
    }

    // Meme templates data
    const memeTemplates = [
        { name: "Drake", url: "https://i.imgflip.com/30b1gx.jpg" },
        { name: "Doge", url: "https://i.imgflip.com/4t0m5.jpg" },
        { name: "Mocking Spongebob", url: "https://i.imgflip.com/1otk96.jpg" },
        { name: "Two Buttons", url: "https://i.imgflip.com/1g8my4.jpg" },
        { name: "Change My Mind", url: "https://i.imgflip.com/24y43o.jpg" },
        { name: "Woman Yelling at Cat", url: "https://i.imgflip.com/345v97.jpg" },
        { name: "Distracted Boyfriend", url: "https://i.imgflip.com/1ur9b0.jpg" },
        { name: "Left Exit 12", url: "https://i.imgflip.com/22bdq6.jpg" },
        { name: "Running Away Balloon", url: "https://i.imgflip.com/261o3j.jpg" },
        { name: "Winnie the Pooh", url: "https://i.imgflip.com/2ybua0.jpg" }
    ];

    // User templates storage
    let userTemplates = JSON.parse(localStorage.getItem('userTemplates')) || [];

    // Set text mode (single or multi line)
    function setTextMode(mode) {
        textMode = mode;
        
        // Update button states
        document.querySelectorAll('.text-mode-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        event.target.classList.add('active');
        
        // Show/hide text inputs
        if (mode === 'single') {
            document.getElementById('singleLineText').style.display = 'block';
            document.getElementById('multiLineText').style.display = 'none';
        } else {
            document.getElementById('singleLineText').style.display = 'none';
            document.getElementById('multiLineText').style.display = 'block';
        }
        
        drawMeme();
    }

    // Dark mode toggle functionality
    document.getElementById("toggle-dark").addEventListener("change", function() {
        document.body.classList.toggle("dark", this.checked);
    });

    // Create text handles
    function createTextHandles() {
        const canvasContainer = canvas.parentElement;
        
        // Remove existing handles
        document.querySelectorAll('.text-handle').forEach(handle => handle.remove());
        
        // Create top text handle
        topHandle = document.createElement('div');
        topHandle.className = 'text-handle top';
        topHandle.style.position = 'absolute';
        topHandle.innerHTML = '<div style="color: white; font-size: 8px; text-align: center; line-height: 25px;">T</div>';
        canvasContainer.appendChild(topHandle);
        
        // Create bottom text handle
        bottomHandle = document.createElement('div');
        bottomHandle.className = 'text-handle bottom';
        bottomHandle.style.position = 'absolute';
        bottomHandle.innerHTML = '<div style="color: white; font-size: 8px; text-align: center; line-height: 25px;">B</div>';
        canvasContainer.appendChild(bottomHandle);
        
        // Create size handle
        sizeHandle = document.createElement('div');
        sizeHandle.className = 'text-handle size';
        sizeHandle.style.position = 'absolute';
        sizeHandle.innerHTML = '<div style="color: white; font-size: 6px; text-align: center; line-height: 20px;">S</div>';
        canvasContainer.appendChild(sizeHandle);
        
        // Add event listeners
        setupDragEvents(topHandle, 'top');
        setupDragEvents(bottomHandle, 'bottom');
        setupDragEvents(sizeHandle, 'size');
        
        // Add pinch to zoom for mobile
        if (isMobileDevice()) {
            setupPinchToZoom();
        }
        
        updateHandlePositions();
    }

    // Setup pinch to zoom for mobile
    function setupPinchToZoom() {
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd);
    }

    function handleTouchStart(e) {
        if (e.touches.length === 2) {
            e.preventDefault();
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            touchStartDistance = Math.hypot(
                touch1.clientX - touch2.clientX,
                touch1.clientY - touch2.clientY
            );
            initialTextSize = textSize;
        }
    }

    function handleTouchMove(e) {
        if (e.touches.length === 2) {
            e.preventDefault();
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const currentDistance = Math.hypot(
                touch1.clientX - touch2.clientX,
                touch1.clientY - touch2.clientY
            );
            
            if (touchStartDistance > 0) {
                const scale = currentDistance / touchStartDistance;
                textSize = Math.max(1, Math.min(100, Math.round(initialTextSize * scale)));
                document.getElementById('textSize').value = textSize;
                document.getElementById('textSizeValue').textContent = textSize + 'px';
                drawMeme();
            }
        }
    }

    function handleTouchEnd() {
        touchStartDistance = 0;
    }

    // Setup drag events for handles
    function setupDragEvents(handle, type) {
        // Mouse events for desktop
        handle.addEventListener('mousedown', startDrag);
        
        // Touch events for mobile
        handle.addEventListener('touchstart', function(e) {
            e.preventDefault();
            startDrag(e.touches[0]);
        }, { passive: false });
        
        function startDrag(e) {
            isDragging = true;
            currentHandle = type;
            startX = e.clientX;
            startY = e.clientY;
            startTopX = topTextX;
            startTopY = topTextY;
            startBottomX = bottomTextX;
            startBottomY = bottomTextY;
            startTextSize = textSize;
            
            // Add move and end listeners
            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', touchDrag, { passive: false });
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
            
            e.preventDefault();
        }
        
        function drag(e) {
            if (!isDragging) return;
            handleDrag(e.clientX, e.clientY);
        }
        
        function touchDrag(e) {
            if (!isDragging) return;
            e.preventDefault();
            handleDrag(e.touches[0].clientX, e.touches[0].clientY);
        }
        
        function stopDrag() {
            isDragging = false;
            currentHandle = null;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('touchmove', touchDrag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchend', stopDrag);
        }
    }

    // Handle drag movement
    function handleDrag(clientX, clientY) {
        const canvasRect = canvas.getBoundingClientRect();
        const deltaX = clientX - startX;
        const deltaY = clientY - startY;
        
        // Convert pixels to percentages
        const deltaXPercent = (deltaX / canvasRect.width) * 100;
        const deltaYPercent = (deltaY / canvasRect.height) * 100;
        
        // Adjust sensitivity for mobile
        const sensitivity = isMobileDevice() ? 1.2 : 1.0;
        
        switch(currentHandle) {
            case 'top':
                topTextX = Math.max(0, Math.min(100, startTopX + deltaXPercent * sensitivity));
                topTextY = Math.max(0, Math.min(100, startTopY + deltaYPercent * sensitivity));
                break;
            case 'bottom':
                bottomTextX = Math.max(0, Math.min(100, startBottomX + deltaXPercent * sensitivity));
                bottomTextY = Math.max(0, Math.min(100, startBottomY + deltaYPercent * sensitivity));
                break;
            case 'size':
                const sizeDelta = deltaY * (isMobileDevice() ? -0.5 : -0.3);
                textSize = Math.max(1, Math.min(100, startTextSize + sizeDelta));
                document.getElementById('textSize').value = textSize;
                document.getElementById('textSizeValue').textContent = textSize + 'px';
                break;
        }
        
        updateHandlePositions();
        drawMeme();
    }

    // Update handle positions
    function updateHandlePositions() {
        if (!topHandle || !bottomHandle || !sizeHandle) return;
        
        const canvasRect = canvas.getBoundingClientRect();
        const containerRect = canvas.parentElement.getBoundingClientRect();
        
        const topX = (topTextX / 100) * canvasRect.width + canvasRect.left - containerRect.left;
        const topY = (topTextY / 100) * canvasRect.height + canvasRect.top - containerRect.top;
        const bottomX = (bottomTextX / 100) * canvasRect.width + canvasRect.left - containerRect.left;
        const bottomY = (bottomTextY / 100) * canvasRect.height + canvasRect.top - containerRect.top;
        
        const handleSize = isMobileDevice() ? 35 : 25;
        
        topHandle.style.left = (topX - handleSize/2) + 'px';
        topHandle.style.top = (topY - handleSize/2) + 'px';
        
        bottomHandle.style.left = (bottomX - handleSize/2) + 'px';
        bottomHandle.style.top = (bottomY - handleSize/2) + 'px';
        
        sizeHandle.style.left = (bottomX + handleSize) + 'px';
        sizeHandle.style.top = (bottomY - handleSize/2) + 'px';
    }

    // Initialize slider values and event listeners
    function initializeSliders() {
        const sliders = [
            { id: 'textSize', variable: 'textSize', suffix: 'px' },
            { id: 'strokeWidth', variable: 'strokeWidth', suffix: 'px' }
        ];

        sliders.forEach(slider => {
            const sliderElement = document.getElementById(slider.id);
            const valueElement = document.getElementById(slider.id + 'Value');
            
            if (sliderElement && valueElement) {
                sliderElement.value = window[slider.variable];
                valueElement.textContent = window[slider.variable] + slider.suffix;
                
                sliderElement.addEventListener('input', function() {
                    window[slider.variable] = parseInt(this.value);
                    valueElement.textContent = window[slider.variable] + slider.suffix;
                    updateHandlePositions();
                    drawMeme();
                });
            }
        });

        // Color pickers
        const textColorPicker = document.getElementById('textColor');
        const strokeColorPicker = document.getElementById('strokeColor');
        const textColorPreview = document.getElementById('textColorPreview');
        const strokeColorPreview = document.getElementById('strokeColorPreview');

        textColorPicker.value = textColor;
        strokeColorPicker.value = strokeColor;
        textColorPreview.style.backgroundColor = textColor;
        strokeColorPreview.style.backgroundColor = strokeColor;

        textColorPicker.addEventListener('input', function() {
            textColor = this.value;
            textColorPreview.style.backgroundColor = textColor;
            drawMeme();
        });

        strokeColorPicker.addEventListener('input', function() {
            strokeColor = this.value;
            strokeColorPreview.style.backgroundColor = strokeColor;
            drawMeme();
        });
    }

    // Initialize template gallery
    function initializeTemplateGallery() {
        const templateGrid = document.getElementById('templateGrid');
        const userTemplatesGrid = document.getElementById('userTemplatesGrid');
        const templateSearch = document.getElementById('templateSearch');
        
        function loadTemplates(templates, container, filter = '') {
            container.innerHTML = '';
            const filteredTemplates = templates.filter(template => 
                template.name.toLowerCase().includes(filter.toLowerCase())
            );
            
            if (filteredTemplates.length === 0) {
                container.innerHTML = '<div class="text-center w-100 py-2 text-muted" style="font-size: 10px;">No templates found</div>';
                return;
            }
            
            filteredTemplates.forEach((template) => {
                const templateItem = document.createElement('div');
                templateItem.className = 'template-item';
                templateItem.innerHTML = `
                    <img src="${template.url}" alt="${template.name}" class="template-img" loading="lazy" onerror="this.src='https://via.placeholder.com/150/cccccc/666666?text=Error'">
                    <p class="template-name">${template.name}</p>
                `;
                
                templateItem.addEventListener('click', () => {
                    document.querySelectorAll('.template-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    templateItem.classList.add('active');
                    loadImage(template.url);
                });
                
                container.appendChild(templateItem);
            });
        }
        
        loadTemplates(memeTemplates, templateGrid);
        loadTemplates(userTemplates, userTemplatesGrid);
        
        templateSearch.addEventListener('input', (e) => {
            loadTemplates(memeTemplates, templateGrid, e.target.value);
            loadTemplates(userTemplates, userTemplatesGrid, e.target.value);
        });
        
        setTimeout(() => {
            const hasActive = document.querySelector('.template-item.active');
            if (!hasActive && memeTemplates.length > 0) {
                const firstItem = templateGrid.querySelector('.template-item');
                if (firstItem) {
                    firstItem.classList.add('active');
                    loadImage(memeTemplates[0].url);
                }
            }
        }, 100);
    }
    
    // Add user template
    function addUserTemplate() {
        const fileInput = document.getElementById('uploadTemplate');
        const nameInput = document.getElementById('templateNameInput');
        const file = fileInput.files[0];
        const name = nameInput.value.trim();
        
        if (!file) {
            alert('Please select an image file');
            return;
        }
        
        if (!name) {
            alert('Please enter a template name');
            return;
        }
        
        const reader = new FileReader();
        reader.onload = function(e) {
            const newTemplate = {
                name: name,
                url: e.target.result
            };
            
            userTemplates.push(newTemplate);
            localStorage.setItem('userTemplates', JSON.stringify(userTemplates));
            initializeTemplateGallery();
            fileInput.value = '';
            nameInput.value = '';
            alert('Template added!');
        };
        reader.readAsDataURL(file);
    }

    function loadImage(src) {
        currentImage = new Image();
        currentImage.crossOrigin = "anonymous";
        currentImage.src = src;
        currentImage.onload = () => {
            const maxWidth = isMobileDevice() ? (window.innerWidth - 10) : 500;
            const scaleFactor = maxWidth / currentImage.width;
            
            canvas.width = maxWidth;
            canvas.height = currentImage.height * scaleFactor;
            
            createTextHandles();
            drawMeme();
        };
        
        currentImage.onerror = () => {
            console.error('Failed to load image:', src);
            alert('Failed to load template');
        };
    }

    function drawMeme() {
        const topText = document.getElementById("topText").value;
        const bottomText = document.getElementById("bottomText").value;
        const multiText = document.getElementById("multiText").value;

        if (!currentImage.complete) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);

        // Use the exact text size from slider (1px to 100px)
        ctx.font = `bold ${textSize}px Impact`;
        ctx.fillStyle = textColor;
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = strokeWidth;
        ctx.textAlign = "center";

        if (textMode === 'single') {
            // Single line mode - top and bottom text
            const topX = (topTextX / 100) * canvas.width;
            const topY = (topTextY / 100) * canvas.height;
            const bottomX = (bottomTextX / 100) * canvas.width;
            const bottomY = (bottomTextY / 100) * canvas.height;

            if (topText) {
                ctx.strokeText(topText.toUpperCase(), topX, topY);
                ctx.fillText(topText.toUpperCase(), topX, topY);
            }

            if (bottomText) {
                ctx.strokeText(bottomText.toUpperCase(), bottomX, bottomY);
                ctx.fillText(bottomText.toUpperCase(), bottomX, bottomY);
            }
        } else {
            // Multi line mode - stack text vertically
            const lines = multiText.split('\n').filter(line => line.trim() !== '');
            const totalLines = lines.length;
            
            if (totalLines > 0) {
                const startY = (topTextY / 100) * canvas.height;
                const lineHeight = textSize * 1.2; // Space between lines
                
                lines.forEach((line, index) => {
                    const yPos = startY + (index * lineHeight);
                    const xPos = (topTextX / 100) * canvas.width;
                    
                    if (line.trim()) {
                        ctx.strokeText(line.toUpperCase(), xPos, yPos);
                        ctx.fillText(line.toUpperCase(), xPos, yPos);
                    }
                });
            }
        }
        
        if (topHandle) {
            updateHandlePositions();
        }
    }

    function downloadMeme() {
        if (!currentImage.complete) {
            alert('Please wait for image to load');
            return;
        }
        
        const link = document.createElement("a");
        link.download = "meme.png";
        link.href = canvas.toDataURL();
        link.click();
    }

    // Handle window resize
    window.addEventListener('resize', function() {
        if (currentImage.src && currentImage.complete) {
            const maxWidth = isMobileDevice() ? (window.innerWidth - 10) : 500;
            const scaleFactor = maxWidth / currentImage.width;
            
            canvas.width = maxWidth;
            canvas.height = currentImage.height * scaleFactor;
            
            updateHandlePositions();
            drawMeme();
        }
    });

    // Handle orientation change
    window.addEventListener('orientationchange', function() {
        setTimeout(() => {
            if (currentImage.src && currentImage.complete) {
                const maxWidth = isMobileDevice() ? (window.innerWidth - 10) : 500;
                const scaleFactor = maxWidth / currentImage.width;
                
                canvas.width = maxWidth;
                canvas.height = currentImage.height * scaleFactor;
                
                updateHandlePositions();
                drawMeme();
            }
        }, 100);
    });

    // Initialize everything
    window.addEventListener('load', function() {
        initializeSliders();
        initializeTemplateGallery();
    });
</script>

</body>
</html>
