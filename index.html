<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meme Generator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container py-4">
        <header class="text-center mb-4">
            <div class="d-flex justify-content-between align-items-center">
                <h1 class="display-4 fw-bold text-primary">üé® Meme Generator</h1>
                <div class="dark-mode-toggle">
                    <input type="checkbox" id="toggle-dark">
                    <label for="toggle-dark" id="darkToggle">
                        <div class="circle">
                            <svg class="sun" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 18a6 6 0 100-12 6 6 0 000 12z"/>
                            </svg>
                            <svg class="moon" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M21 12.79A9 9 0 0111.21 3a7 7 0 108.58 8.58 9.05 9.05 0 011.21 1.21z"/>
                            </svg>
                        </div>
                    </label>
                </div>
            </div>
            <p class="lead text-muted">Create professional memes with drag & resize text areas</p>
        </header>

        <div class="row g-4">
            <!-- Left Panel - Controls -->
            <div class="col-md-4">
                <div class="card shadow-sm mb-4">
                    <div class="card-body">
                        <h5 class="card-title">üìÅ Templates</h5>
                        
                        <div class="template-search mb-3">
                            <input type="text" id="templateSearch" class="form-control" placeholder="Search templates...">
                        </div>
                        
                        <div class="template-gallery">
                            <div class="template-grid" id="templateGrid">
                                <!-- Templates will be loaded here -->
                            </div>
                        </div>

                        <div class="upload-section mt-3">
                            <input type="file" id="uploadTemplate" class="form-control mb-2" accept="image/*">
                            <button onclick="addUserTemplate()" class="btn btn-outline-primary w-100">Upload Your Image</button>
                        </div>
                    </div>
                </div>

                <div class="card shadow-sm">
                    <div class="card-body">
                        <h5 class="card-title">‚úèÔ∏è Text Controls</h5>
                        
                        <div class="text-controls">
                            <div class="d-flex gap-2 mb-3">
                                <button onclick="addTextArea()" class="btn btn-primary btn-sm flex-fill">+ Add Text Area</button>
                                <button onclick="clearAllText()" class="btn btn-outline-danger btn-sm">Clear All</button>
                            </div>

                            <div class="text-areas-container" id="textAreasContainer">
                                <!-- Text areas will be added here -->
                            </div>

                            <div class="text-properties mt-3">
                                <div class="position-controls">
                                    <h6 class="fw-bold mb-2">Text Properties</h6>
                                    
                                    <div class="slider-group">
                                        <label>Text Size:</label>
                                        <div class="slider-container">
                                            <input type="range" id="textSize" class="form-range" min="16" max="80" value="36">
                                            <span id="textSizeValue" class="slider-value">36px</span>
                                        </div>
                                    </div>

                                    <div class="slider-group">
                                        <label>Stroke Width:</label>
                                        <div class="slider-container">
                                            <input type="range" id="strokeWidth" class="form-range" min="0" max="8" value="3">
                                            <span id="strokeWidthValue" class="slider-value">3px</span>
                                        </div>
                                    </div>

                                    <!-- Color Controls -->
                                    <div class="color-controls">
                                        <div class="color-group">
                                            <label>Text Color:</label>
                                            <div class="color-input-group">
                                                <input type="color" id="textColor" value="#ffffff" class="form-control form-control-color">
                                                <div id="textColorPreview" class="color-preview" style="background-color: #ffffff;"></div>
                                            </div>
                                        </div>
                                        
                                        <div class="color-group">
                                            <label>Stroke Color:</label>
                                            <div class="color-input-group">
                                                <input type="color" id="strokeColor" value="#000000" class="form-control form-control-color">
                                                <div id="strokeColorPreview" class="color-preview" style="background-color: #000000;"></div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="row g-2 mt-2">
                                        <div class="col-12">
                                            <label class="form-label">Font Family</label>
                                            <select id="fontFamily" class="form-select">
                                                <option value="Impact">Impact</option>
                                                <option value="Arial Black">Arial Black</option>
                                                <option value="Comic Sans MS">Comic Sans</option>
                                                <option value="Verdana">Verdana</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="d-grid gap-2 mt-3">
                            <button onclick="updateMeme()" class="btn btn-success">Update Meme</button>
                            <button onclick="downloadMeme()" class="btn btn-primary">üíæ Download Meme</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Panel - Canvas -->
            <div class="col-md-8">
                <div class="card shadow-sm">
                    <div class="card-body text-center">
                        <div class="canvas-container position-relative">
                            <canvas id="memeCanvas"></canvas>
                            <div class="canvas-overlay" id="canvasOverlay">
                                <!-- Text areas will be positioned here -->
                            </div>
                            <div class="zoom-controls">
                                <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
                                <div class="zoom-value" id="zoomValue">100%</div>
                                <button class="zoom-btn" onclick="zoomIn()">+</button>
                                <button class="zoom-btn" onclick="resetZoom()">Reset</button>
                            </div>
                        </div>
                        <div class="mt-3">
                            <small class="text-muted">
                                üí° Drag text to move ‚Ä¢ Drag corners to resize ‚Ä¢ Scroll to zoom
                            </small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Meme Generator Application
        const canvas = document.getElementById('memeCanvas');
        const ctx = canvas.getContext('2d');
        const canvasOverlay = document.getElementById('canvasOverlay');
        const textAreasContainer = document.getElementById('textAreasContainer');

        // Current state
        let currentImage = null;
        let textAreas = [];
        let canvasScale = 1.0;
        let canvasOffsetX = 0;
        let canvasOffsetY = 0;
        let isDragging = false;
        let isResizing = false;
        let isPanning = false;
        let currentDragElement = null;
        let currentResizeHandle = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let startPanX = 0;
        let startPanY = 0;

        // Meme templates - Big clear images
        const memeTemplates = [
            { name: "Drake", url: "https://i.imgflip.com/30b1gx.jpg" },
            { name: "Doge", url: "https://i.imgflip.com/4t0m5.jpg" },
            { name: "Two Buttons", url: "https://i.imgflip.com/1g8my4.jpg" },
            { name: "Distracted Boyfriend", url: "https://i.imgflip.com/1ur9b0.jpg" },
            { name: "Change My Mind", url: "https://i.imgflip.com/24y43o.jpg" },
            { name: "Woman Yelling at Cat", url: "https://i.imgflip.com/345v97.jpg" },
            { name: "Left Exit 12", url: "https://i.imgflip.com/22bdq6.jpg" },
            { name: "Running Away Balloon", url: "https://i.imgflip.com/261o3j.jpg" }
        ];

        // User templates
        let userTemplates = JSON.parse(localStorage.getItem('userTemplates')) || [];

        // Initialize the application
        function init() {
            setupDarkMode();
            setupEventListeners();
            initializeTemplateGallery();
            loadImage(memeTemplates[0].url);
            addDefaultTextAreas();
            updateZoomDisplay();
        }

        // Setup dark mode with original toggle
        function setupDarkMode() {
            const darkModeToggle = document.getElementById('toggle-dark');
            const savedMode = localStorage.getItem('darkMode');
            
            if (savedMode === 'enabled') {
                darkModeToggle.checked = true;
                document.body.classList.add("dark");
            }
            
            darkModeToggle.addEventListener('change', function() {
                document.body.classList.toggle("dark", this.checked);
                localStorage.setItem('darkMode', this.checked ? 'enabled' : 'disabled');
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            // Text controls
            document.getElementById('textSize').addEventListener('input', function() {
                document.getElementById('textSizeValue').textContent = this.value + 'px';
                updateAllTextAreas();
            });

            document.getElementById('strokeWidth').addEventListener('input', function() {
                document.getElementById('strokeWidthValue').textContent = this.value + 'px';
                updateAllTextAreas();
            });

            document.getElementById('textColor').addEventListener('input', function() {
                document.getElementById('textColorPreview').style.backgroundColor = this.value;
                updateAllTextAreas();
            });

            document.getElementById('strokeColor').addEventListener('input', function() {
                document.getElementById('strokeColorPreview').style.backgroundColor = this.value;
                updateAllTextAreas();
            });

            document.getElementById('fontFamily').addEventListener('change', updateAllTextAreas);

            // Template search
            document.getElementById('templateSearch').addEventListener('input', function(e) {
                filterTemplates(e.target.value.toLowerCase());
            });

            // Canvas interactions
            canvas.addEventListener('wheel', handleZoom);
            canvas.addEventListener('mousedown', startPan);

            // Window resize
            window.addEventListener('resize', function() {
                if (currentImage) {
                    updateCanvasSize();
                    updateAllTextAreas();
                }
            });
        }

        // Initialize template gallery
        function initializeTemplateGallery() {
            const templateGrid = document.getElementById('templateGrid');
            loadTemplatesToGrid([...memeTemplates, ...userTemplates], templateGrid);
        }

        // Load templates to grid
        function loadTemplatesToGrid(templates, container) {
            container.innerHTML = '';
            
            templates.forEach((template, index) => {
                const templateItem = document.createElement('div');
                templateItem.className = 'template-item';
                templateItem.innerHTML = `
                    <img src="${template.url}" alt="${template.name}" class="template-img">
                    <div class="template-name">${template.name}</div>
                `;
                
                templateItem.addEventListener('click', () => {
                    document.querySelectorAll('.template-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    templateItem.classList.add('active');
                    loadImage(template.url);
                });
                
                container.appendChild(templateItem);
            });
            
            // Activate first template
            if (templates.length > 0) {
                const firstItem = container.querySelector('.template-item');
                if (firstItem) {
                    firstItem.classList.add('active');
                }
            }
        }

        // Filter templates
        function filterTemplates(searchTerm) {
            const allTemplates = [...memeTemplates, ...userTemplates];
            const filteredTemplates = allTemplates.filter(template => 
                template.name.toLowerCase().includes(searchTerm)
            );
            
            const templateGrid = document.getElementById('templateGrid');
            loadTemplatesToGrid(filteredTemplates, templateGrid);
        }

        // Load image to canvas
        function loadImage(url) {
            currentImage = new Image();
            currentImage.crossOrigin = "anonymous";
            currentImage.src = url;
            
            currentImage.onload = function() {
                updateCanvasSize();
                textAreas = [];
                canvasOverlay.innerHTML = '';
                textAreasContainer.innerHTML = '';
                addDefaultTextAreas();
                updateMeme();
            };
            
            currentImage.onerror = function() {
                alert('Failed to load image. Please try another template.');
            };
        }

        // Update canvas size
        function updateCanvasSize() {
            const maxWidth = 800;
            const maxHeight = 600;
            const scale = Math.min(maxWidth / currentImage.width, maxHeight / currentImage.height, 1);
            
            canvas.width = currentImage.width * scale;
            canvas.height = currentImage.height * scale;
            
            // Update overlay size
            canvasOverlay.style.width = canvas.width + 'px';
            canvasOverlay.style.height = canvas.height + 'px';
        }

        // Add default text areas
        function addDefaultTextAreas() {
            addTextArea("TOP TEXT", 50, 20, 300, 80);
            addTextArea("BOTTOM TEXT", 50, 80, 300, 80);
        }

        // Add text area
        function addTextArea(text = "YOUR TEXT", x = 50, y = 50, width = 200, height = 60) {
            const id = 'text_' + Date.now();
            const textArea = {
                id,
                text,
                x,
                y,
                width,
                height
            };
            
            textAreas.push(textArea);
            createTextAreaElement(textArea);
            createTextAreaControl(textArea);
        }

        // Create text area element
        function createTextAreaElement(textArea) {
            const textElement = document.createElement('div');
            textElement.className = 'text-area';
            textElement.id = `text-${textArea.id}`;
            textElement.innerHTML = `
                <div class="text-content">${textArea.text}</div>
                <div class="resize-handle top-left"></div>
                <div class="resize-handle top-right"></div>
                <div class="resize-handle bottom-left"></div>
                <div class="resize-handle bottom-right"></div>
                <div class="delete-handle" onclick="deleteTextArea('${textArea.id}')">√ó</div>
            `;
            
            updateTextAreaPosition(textElement, textArea);
            updateTextAreaStyle(textElement);
            setupTextAreaInteractions(textElement, textArea);
            
            canvasOverlay.appendChild(textElement);
        }

        // Create text area control
        function createTextAreaControl(textArea) {
            const control = document.createElement('div');
            control.className = 'text-area-control';
            control.innerHTML = `
                <div class="d-flex align-items-center gap-2 p-2 border rounded">
                    <input type="text" 
                           class="form-control form-control-sm" 
                           value="${textArea.text}" 
                           placeholder="Enter text..."
                           oninput="updateTextAreaText('${textArea.id}', this.value)">
                    <button class="btn btn-sm btn-outline-danger" onclick="deleteTextArea('${textArea.id}')">√ó</button>
                </div>
            `;
            
            textAreasContainer.appendChild(control);
        }

        // Setup text area interactions
        function setupTextAreaInteractions(textElement, textArea) {
            let startX, startY, startWidth, startHeight, startLeft, startTop;
            
            // Drag functionality
            textElement.addEventListener('mousedown', startDrag);
            
            // Resize functionality for each handle
            const resizeHandles = textElement.querySelectorAll('.resize-handle');
            resizeHandles.forEach(handle => {
                handle.addEventListener('mousedown', startResize);
            });

            function startDrag(e) {
                if (e.target.classList.contains('resize-handle') || e.target.classList.contains('delete-handle')) {
                    return;
                }
                
                e.preventDefault();
                isDragging = true;
                currentDragElement = textArea;
                
                const rect = textElement.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                
                dragOffsetX = e.clientX - rect.left;
                dragOffsetY = e.clientY - rect.top;
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
            }

            function startResize(e) {
                e.preventDefault();
                e.stopPropagation();
                
                isResizing = true;
                currentResizeHandle = e.target;
                currentDragElement = textArea;
                
                const rect = textElement.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                
                startX = e.clientX;
                startY = e.clientY;
                startWidth = parseInt(document.defaultView.getComputedStyle(textElement).width, 10);
                startHeight = parseInt(document.defaultView.getComputedStyle(textElement).height, 10);
                startLeft = rect.left - canvasRect.left;
                startTop = rect.top - canvasRect.top;
                
                document.addEventListener('mousemove', resize);
                document.addEventListener('mouseup', stopResize);
            }

            function drag(e) {
                if (!isDragging || currentDragElement !== textArea) return;
                
                const canvasRect = canvas.getBoundingClientRect();
                const x = ((e.clientX - dragOffsetX - canvasRect.left + textElement.offsetWidth / 2) / canvasRect.width) * 100;
                const y = ((e.clientY - dragOffsetY - canvasRect.top + textElement.offsetHeight / 2) / canvasRect.height) * 100;
                
                textArea.x = Math.max(5, Math.min(95, x));
                textArea.y = Math.max(5, Math.min(95, y));
                
                updateTextAreaPosition(textElement, textArea);
            }

            function resize(e) {
                if (!isResizing || currentDragElement !== textArea) return;
                
                const canvasRect = canvas.getBoundingClientRect();
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                let newWidth = startWidth;
                let newHeight = startHeight;
                let newLeft = startLeft;
                let newTop = startTop;

                if (currentResizeHandle.classList.contains('bottom-right')) {
                    newWidth = startWidth + dx;
                    newHeight = startHeight + dy;
                } else if (currentResizeHandle.classList.contains('bottom-left')) {
                    newWidth = startWidth - dx;
                    newHeight = startHeight + dy;
                    newLeft = startLeft + dx;
                } else if (currentResizeHandle.classList.contains('top-right')) {
                    newWidth = startWidth + dx;
                    newHeight = startHeight - dy;
                    newTop = startTop + dy;
                } else if (currentResizeHandle.classList.contains('top-left')) {
                    newWidth = startWidth - dx;
                    newHeight = startHeight - dy;
                    newLeft = startLeft + dx;
                    newTop = startTop + dy;
                }

                // Minimum size
                newWidth = Math.max(100, newWidth);
                newHeight = Math.max(40, newHeight);

                // Update text area dimensions
                textArea.width = newWidth;
                textArea.height = newHeight;
                
                // Update position if resizing from left or top
                if (currentResizeHandle.classList.contains('bottom-left') || currentResizeHandle.classList.contains('top-left')) {
                    const newX = ((newLeft + newWidth / 2) / canvasRect.width) * 100;
                    textArea.x = Math.max(5, Math.min(95, newX));
                }
                if (currentResizeHandle.classList.contains('top-right') || currentResizeHandle.classList.contains('top-left')) {
                    const newY = ((newTop + newHeight / 2) / canvasRect.height) * 100;
                    textArea.y = Math.max(5, Math.min(95, newY));
                }

                updateTextAreaPosition(textElement, textArea);
            }

            function stopDrag() {
                isDragging = false;
                currentDragElement = null;
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', stopDrag);
                updateMeme();
            }

            function stopResize() {
                isResizing = false;
                currentResizeHandle = null;
                currentDragElement = null;
                document.removeEventListener('mousemove', resize);
                document.removeEventListener('mouseup', stopResize);
                updateMeme();
            }
        }

        // Update text area position
        function updateTextAreaPosition(textElement, textArea) {
            const canvasRect = canvas.getBoundingClientRect();
            const x = (textArea.x / 100) * canvasRect.width;
            const y = (textArea.y / 100) * canvasRect.height;
            
            textElement.style.left = (x - textArea.width / 2) + 'px';
            textElement.style.top = (y - textArea.height / 2) + 'px';
            textElement.style.width = textArea.width + 'px';
            textElement.style.height = textArea.height + 'px';
        }

        // Update text area style
        function updateTextAreaStyle(textElement) {
            const textSize = document.getElementById('textSize').value;
            const strokeWidth = document.getElementById('strokeWidth').value;
            const textColor = document.getElementById('textColor').value;
            const strokeColor = document.getElementById('strokeColor').value;
            const fontFamily = document.getElementById('fontFamily').value;
            
            textElement.style.fontSize = textSize + 'px';
            textElement.style.color = textColor;
            textElement.style.fontFamily = fontFamily;
            textElement.style.textShadow = `
                ${strokeWidth}px ${strokeWidth}px 0 ${strokeColor},
                -${strokeWidth}px -${strokeWidth}px 0 ${strokeColor},
                ${strokeWidth}px -${strokeWidth}px 0 ${strokeColor},
                -${strokeWidth}px ${strokeWidth}px 0 ${strokeColor}
            `;
        }

        // Update text area text
        function updateTextAreaText(id, newText) {
            const textArea = textAreas.find(area => area.id === id);
            if (textArea) {
                textArea.text = newText;
                const textElement = document.getElementById(`text-${id}`);
                if (textElement) {
                    textElement.querySelector('.text-content').textContent = newText;
                }
                updateMeme();
            }
        }

        // Update all text areas
        function updateAllTextAreas() {
            textAreas.forEach(textArea => {
                const textElement = document.getElementById(`text-${textArea.id}`);
                if (textElement) {
                    updateTextAreaStyle(textElement);
                }
            });
            updateMeme();
        }

        // Delete text area
        function deleteTextArea(id) {
            textAreas = textAreas.filter(area => area.id !== id);
            
            // Remove from DOM
            const textElement = document.getElementById(`text-${id}`);
            if (textElement) textElement.remove();
            
            // Remove control
            const controls = textAreasContainer.querySelectorAll('.text-area-control');
            controls.forEach(control => {
                if (control.querySelector(`[oninput*="${id}"]`)) {
                    control.remove();
                }
            });
            
            updateMeme();
        }

        // Clear all text
        function clearAllText() {
            if (confirm('Are you sure you want to remove all text areas?')) {
                textAreas = [];
                canvasOverlay.innerHTML = '';
                textAreasContainer.innerHTML = '';
                updateMeme();
            }
        }

        // Handle zoom
        function handleZoom(e) {
            e.preventDefault();
            const zoomIntensity = 0.1;
            const wheel = e.deltaY < 0 ? 1 : -1;
            const zoom = Math.exp(wheel * zoomIntensity);
            
            canvasScale = Math.max(0.5, Math.min(3, canvasScale * zoom));
            updateZoomDisplay();
            updateMeme();
        }

        // Start pan
        function startPan(e) {
            if (e.button !== 0 || isDragging || isResizing) return;
            isPanning = true;
            startPanX = e.clientX - canvasOffsetX;
            startPanY = e.clientY - canvasOffsetY;
            canvas.style.cursor = 'grabbing';
            
            document.addEventListener('mousemove', pan);
            document.addEventListener('mouseup', stopPan);
        }

        // Pan
        function pan(e) {
            if (!isPanning) return;
            canvasOffsetX = e.clientX - startPanX;
            canvasOffsetY = e.clientY - startPanY;
            updateMeme();
        }

        // Stop pan
        function stopPan() {
            isPanning = false;
            canvas.style.cursor = 'default';
            document.removeEventListener('mousemove', pan);
            document.removeEventListener('mouseup', stopPan);
        }

        // Zoom in
        function zoomIn() {
            canvasScale = Math.min(3, canvasScale + 0.2);
            updateZoomDisplay();
            updateMeme();
        }

        // Zoom out
        function zoomOut() {
            canvasScale = Math.max(0.5, canvasScale - 0.2);
            updateZoomDisplay();
            updateMeme();
        }

        // Reset zoom
        function resetZoom() {
            canvasScale = 1.0;
            canvasOffsetX = 0;
            canvasOffsetY = 0;
            updateZoomDisplay();
            updateMeme();
        }

        // Update zoom display
        function updateZoomDisplay() {
            document.getElementById('zoomValue').textContent = Math.round(canvasScale * 100) + '%';
        }

        // Update meme canvas
        function updateMeme() {
            if (!currentImage || !currentImage.complete) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply zoom and pan transformations
            ctx.save();
            ctx.translate(canvasOffsetX, canvasOffsetY);
            ctx.scale(canvasScale, canvasScale);
            
            // Draw image
            ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
            
            // Draw text areas
            const textSize = document.getElementById('textSize').value;
            const strokeWidth = document.getElementById('strokeWidth').value;
            const textColor = document.getElementById('textColor').value;
            const strokeColor = document.getElementById('strokeColor').value;
            const fontFamily = document.getElementById('fontFamily').value;
            
            textAreas.forEach(textArea => {
                if (!textArea.text) return;
                
                ctx.font = `bold ${textSize}px ${fontFamily}`;
                ctx.fillStyle = textColor;
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = strokeWidth;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const x = (textArea.x / 100) * canvas.width;
                const y = (textArea.y / 100) * canvas.height;
                
                // Draw stroke
                if (strokeWidth > 0) {
                    ctx.strokeText(textArea.text.toUpperCase(), x, y);
                }
                
                // Draw fill
                ctx.fillText(textArea.text.toUpperCase(), x, y);
            });
            
            ctx.restore();
        }

        // Download meme
        function downloadMeme() {
            if (!currentImage || !currentImage.complete) {
                alert('Please wait for the image to load');
                return;
            }
            
            // Create high-quality canvas
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // Use original dimensions for best quality
            tempCanvas.width = currentImage.width;
            tempCanvas.height = currentImage.height;
            
            // Draw image
            tempCtx.drawImage(currentImage, 0, 0, tempCanvas.width, tempCanvas.height);
            
            // Scale text properties
            const textSize = parseInt(document.getElementById('textSize').value);
            const strokeWidth = parseInt(document.getElementById('strokeWidth').value);
            const textColor = document.getElementById('textColor').value;
            const strokeColor = document.getElementById('strokeColor').value;
            const fontFamily = document.getElementById('fontFamily').value;
            
            const scaleFactor = tempCanvas.width / canvas.width;
            const scaledTextSize = textSize * scaleFactor;
            const scaledStrokeWidth = strokeWidth * scaleFactor;
            
            // Draw text
            textAreas.forEach(textArea => {
                if (!textArea.text) return;
                
                tempCtx.font = `bold ${scaledTextSize}px ${fontFamily}`;
                tempCtx.fillStyle = textColor;
                tempCtx.strokeStyle = strokeColor;
                tempCtx.lineWidth = scaledStrokeWidth;
                tempCtx.textAlign = 'center';
                tempCtx.textBaseline = 'middle';
                
                const x = (textArea.x / 100) * tempCanvas.width;
                const y = (textArea.y / 100) * tempCanvas.height;
                
                if (scaledStrokeWidth > 0) {
                    tempCtx.strokeText(textArea.text.toUpperCase(), x, y);
                }
                tempCtx.fillText(textArea.text.toUpperCase(), x, y);
            });
            
            // Download
            const link = document.createElement('a');
            link.download = 'meme.png';
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        }

        // Add user template
        function addUserTemplate() {
            const fileInput = document.getElementById('uploadTemplate');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select an image file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const name = file.name.split('.')[0] || 'Custom Template';
                const newTemplate = {
                    name: name,
                    url: e.target.result
                };
                
                userTemplates.push(newTemplate);
                localStorage.setItem('userTemplates', JSON.stringify(userTemplates));
                
                // Reload template gallery
                document.getElementById('templateGrid').innerHTML = '';
                initializeTemplateGallery();
                
                fileInput.value = '';
                alert('Template added successfully!');
            };
            reader.readAsDataURL(file);
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
